// Alyssa Rose

#include <string>
#include <cstdio>
#include <sstream>
#include <cstdlib>
#include <iostream>

#include "highScoresList.h"
#include "game.h"
#include "int-string.h"
using namespace std;

string const UP = "w";
string const DOWN = "s";
string const LEFT = "a";
string const RIGHT = "d";
string const DISP5 = "h";
string const QUIT = "q";
string const BLNK = "-";

string const CLR = "clear";
string const SHOW = "show";
string const KEEP = "keep";

/*
* Purpose: standard constructor
* Effects: initializes private variables
*/ 	
Game::Game(){
	cout << "Enter desired dimension of board: ";
	cin >> dim;
	Row = dim;
	Col = dim;
	board = nullptr;
	srand(time(0));
	score = 0;
}

/*
* Purpose: prints string in formatted way
* Effects: none
*/
void Game::print_number(string num) {
    printf("%-6s", num.c_str());
}

/*
* Purpose: Implements the game by calling
* helper functions
* Effects: Changes the board which is on the
* heap and the associated private functions
*/
void Game::play(){
	if (dim < 2){
		cerr << "Wrong Dimensions";
		exit(1);
	}
	prt_start();
	new_brd();
	prt_brd();
	//highScores.clear();

	while (filled() or make_mv()){
		string in, in2;
		cin >> in;
		if (in == "show "){
			cin >> in2;
			highScores.printUser(in2);
		}
		if (in == LEFT)
			play_left();
		else if (in == RIGHT)
			play_right();
		else if (in == UP)
			play_up();
		else if (in == DOWN)
			play_down();
		else if (in == QUIT)
			break;
		else
			play_other(in);	
	}
	end_game();
	highScores.save();
}

/*
* Purpose: standard deconstructor
* Effects: deallocates everything on the heap
*/
Game::~Game(){
	for (int i = 0; i < Row; i++)
		delete [] board[i];
	delete [] board;

}

/*
* Purpose: generates either a 2 or
* 4 based on probability
* Returns: string of either "2" or "4"
* Effects: none
*/
string Game::rando_num(){
	double prob = (rand() % 10) + 1;
	if (prob <= 9)
		return "2";
	else
		return "4";
}

/*
* Purpose: generates a random location
* to place the number generated by 
* rando_num
* Effects: changes to board by inserting
* the number into the location
*/
void Game::rando_loc(){
	int col, row;
	row = rand() % dim;
	col = rand() % dim;
	while (board[row][col] != BLNK){
		row = rand() % dim;
		col = rand() % dim;
	}
	board[row][col] = rando_num();
}
/*
* Purpose: creates a new board by dynamically
* allocating it on the heap and filling it with
* "-" except for 2 locations which get "2"
* Effects: creates heap allocated array
*/
void Game::new_brd()
{
	board = new string *[Row];
	for (int i = 0; i < Row; i++)
		board[i] = new string[Col];
	for (int i = 0; i < Row; i++){
		for(int j = 0; j < Col; j++)
			board[i][j] = BLNK;
	}
	int cnt = 0;
	while (cnt < 2) {
		int j = (rand() % dim);
		int i = (rand() % dim);
		if (board[i][j] == BLNK){
			board[i][j] = "2";
			cnt++;
		}
	}
}

/*
* prints starting message
*/
void Game::prt_start(){
	cout << "Starting game! High score is "
	<< highScores.highestScore() << endl;
}

/*
* Purpose: prints the current board by
* iterating through the columns and the rows
* Effects: prints to standard output using
* print_number() function
*/
void Game::prt_brd(){
	cout << "Current score: " << score << endl;
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < Col; j++)
			print_number(board[i][j]);
		cout << endl;
	}
	
}

/*
* Purpose: checks if the board is filled by
* determining if there are any blank spaces
* Returns: 1 if open space, 0 if full
*/
bool Game::filled(){
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < Col; j++){
			if (board[i][j] == BLNK)
				return 1;
		}
	}
	return 0;

}

/*
* Purpose: checks if user can make a move
* by checking all surrounding tiles for a tile
* with the same value
* Returns: 1 if move can be made and a 0 if
* no move is possible
*/
bool Game::make_mv(){
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < Col; j++){
			if ((board[i+1][j] == board[i][j]) or
				(board[i][j+1] == board[i][j]))
				return true;
		}
	}
	return false;
}

void Game::end_game(){
	string name;
	cout << "Game over! Enter your name to record your score: ";
	cin >> name;
	highScores.insert(name, score);
}

//TODO read in 2 words
void Game::play_other (string in){
	if (in == DISP5)
		highScores.printTop5();
	else if(in == CLR)
		highScores.clear();
	else if(in == KEEP)
		highScores.keepTop10();
	else
		cout << "Command not recognized. Please try again.\n";
}


/*
* Purpose: function to push everything left
* if left arrow pushed
* Effects: changes the heap allocated array
* by pushing all numbers to the left and changing
* now open spaces to contain BLNK
*/
void Game::left_push(){
	int col_nxt;
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < Col - 1; j++){
			if (board[i][j] == BLNK){
				for (col_nxt = j + 1; col_nxt < dim; col_nxt++){
					if (board[i][col_nxt] != BLNK){
						board[i][j] = board[i][col_nxt];
						board[i][col_nxt] = BLNK;
						break;
					}
				}
			}

		}
	}

}

/*
* Purpose: function to push everything right
* if left arrow pushed
* Effects: changes the heap allocated array
* by pushing all numbers to the left and changing
* now open spaces to contain BLNK
*/
void Game::right_push(){
	int col_nxt;
	for (int i = 0; i < Row; i++){
		for (int j = (Col - 1); j > 0; j--){
			if (board[i][j] == BLNK){
				for (col_nxt = j - 1; col_nxt >= 0; col_nxt--){
					if (board[i][col_nxt] != BLNK){
						board[i][j] = board[i][col_nxt];
						board[i][col_nxt] = BLNK;
						break;
					}
				}
			}
		}
	}
}

/*
* Purpose: function to push everything down
* if down key pushed
* Effects: changes the heap allocated array
* by pushing all numbers down and changing
* now open spaces to contain BLNK
*/
void Game::down_push(){
	int row_nxt;
	for (int i = (Row - 1); i > 0; i--){
		for (int j = 0; j < Col; j++){
			if (board[i][j] == BLNK){
				for (row_nxt = (i - 1); row_nxt >= 0; row_nxt--){
					if (board[row_nxt][j] != BLNK){
						board[i][j] = board[row_nxt][j];
						board[row_nxt][j] = BLNK;
						break;
					}
				}
			}
		}
	}
}


/*
* Purpose: function to push everything up
* if up key pushed
* Effects: changes the heap allocated array
* by pushing all numbers up and changing
* now open spaces to contain BLNK
*/
void Game::up_push(){
	int row_nxt;
	for (int i = 0; i < dim; i++){
		for (int j = 0; j < dim; j++){
			if (board[i][j] == BLNK){
				for (row_nxt = (i + 1); row_nxt < dim; row_nxt++){
					if(board[row_nxt][j] != BLNK){
						board[i][j] = board[row_nxt][j];
						board[row_nxt][j] = BLNK;
						break;
					}
				}
			}
		}
	}
}


/*
* Purpose: function to merge everything left
* if left arrow pushed
* Effects: changes the heap allocated array
* by merging all same valued tiles if they are
* to the direct right of a tile that has the same val
* now open spaces to contain BLNK
*/
void Game::merge_left(){
	int col_nxt;
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < (Col - 1); j++){
			if (board[i][j] != BLNK){
				for (col_nxt = j + 1; col_nxt < dim; col_nxt++){
					if (board[i][col_nxt] != BLNK){
						if (board[i][col_nxt] == board[i][j]){
							score += (string2int(board[i][j]) * 2);
							board[i][j] = int2string(string2int(board[i][j]) * 2);
							board[i][col_nxt] = BLNK;
							break;
						}
						break;
					}
				}
			}
		}
	}
}

/*
* Purpose: function to merge everything right
* if left arrow pushed
* Effects: changes the heap allocated array
* by merging all same valued tiles if they are
* to the direct left of a tile that has the same val
* now open spaces to contain BLNK
*/
void Game::merge_right(){
	int col_nxt;
	for(int i = 0; i < Row; i++){
		for (int j = (Col - 1); j > 0; j--){
			if (board[i][j] != BLNK){
				for (col_nxt = (j - 1); col_nxt > 0; col_nxt--){
					if (board[i][col_nxt] != BLNK){
						if (board[i][col_nxt] == board[i][j]){
							score += (string2int(board[i][j]) * 2);
							board[i][j] = int2string(string2int(board[i][j]) * 2);
							board[i][col_nxt] = BLNK;
							break;
						}
						break;
					}
				}
			}
		}
	}
}

/*
* Purpose: Move the pieces down
* Return: nothing
*/
void Game::merge_down(){
	int row_nxt;
	for (int i = (Row - 1); i > 0; i--){
		for (int j = 0; j < Col; j++){
			if (board[i][j] != BLNK){
				for (row_nxt = (i - 1); row_nxt > 0; row_nxt--){
					if (board[row_nxt][j] != BLNK){
						if (board[row_nxt][j] == board[i][j]){
							score += (string2int(board[i][j]) * 2);
							board[i][j] = int2string(string2int(board[i][j]) * 2);
							board[row_nxt][j] = BLNK;
							break;
						}
						break;
					}
				}
			}
		}
	}
}

/*
* Function: moves the pieces up
* Return: nothing
*/
void Game::merge_up(){
	int row_nxt;
	for (int i = 0; i < Row; i++){
		for (int j = 0; j < Col; j++){
			if (board[i][j] != BLNK){
				for (row_nxt = (i + 1); row_nxt < dim; row_nxt++){
					if (board[row_nxt][j] != BLNK){
						if(board[row_nxt][j] == board[i][j]){
							score += (string2int(board[i][j]) * 2);
							board[i][j] = int2string(string2int(board[i][j]) * 2);
							board[row_nxt][j] = BLNK;
							break;
						}
						break;
					}
				}
			}
		}
	}

}


/*
* Purpose: collective functions that should be called 
* if LEFT is pressed
* Effects: changes board by calling helper funcs
*/
void Game::play_left(){
	left_push();
	merge_left();
	left_push();
	rando_loc();
	prt_brd();
}

/*
* Purpose: collective functions that should be called 
* if RIGHT is pressed
* Effects: changes board by calling helper funcs
*/
void Game::play_right(){
	right_push();
	merge_right();
	right_push();
	rando_loc();
	prt_brd();
}

/*
* Purpose: collective functions that should be called 
* if up is pressed
* Effects: changes board by calling helper funcs
*/
void Game::play_up(){
	up_push();
	merge_up();
	up_push();
	rando_loc();
	prt_brd();
}

/*
* Purpose: collective functions that should be called 
* if down is pressed
* Effects: changes board by calling helper funcs
*/
void Game::play_down(){
	down_push();
	merge_down();
	down_push();
	rando_loc();
	prt_brd();
}

